/*
Definir estrutura t_list:
    data  -> ponteiro para valor genérico
    next  -> ponteiro para próximo nó

Função add_elem(data, size):
    Alocar memória para novo nó
    Alocar memória para o valor do nó com tamanho 'size'
    Copiar byte a byte o valor de 'data' para 'node->data'
    next do nó = NULL
    Retornar nó

Função append(begin, data, size):
    Criar novo nó usando add_elem(data, size)
    Se lista estiver vazia:
        begin = novo nó
    Senão:
        Percorrer a lista até o último nó
        last->next = novo nó

Função run_list(begin):
    Enquanto begin não for NULL:
        Imprimir valor do nó
        Se existir next, imprimir separador (ex: "->")
        Avançar para o próximo nó

Função free_list(begin):
    Enquanto begin não for NULL:
        Guardar begin->next em tmp
        Liberar memória de begin->data
        Liberar memória do nó begin
        Avançar begin = tmp

Função ft_atoi(str):
    Converter string para inteiro
    Retornar inteiro

Função main(argc, argv):
    Se argc < 2:
        Imprimir mensagem de uso
        Terminar

    lista = NULL
    Para cada argumento argv[i]:
        val = ft_atoi(argv[i])
        append(&lista, &val, sizeof(int))

    run_list(lista)
    free_list(lista)
*/

int ft_isNum(char *n)
{
    int i = 0;
    if(!n)
        return 0;
    if(n[0] == '-' || n[0] == '+')
        i++;
    while(n[i])
    {
        if(n[i] >= '0' && n[i] <= '9')
            return 1;
        i++;
    }
    return 0;
}


void ft_sorted_list_insert(t_list **begin_list, void *data, int (*cmp)())
{
    t_list *new = add_elem(data, sizeof(int));
    t_list *node = *begin_list;
    
    if(!*begin_list || cmp (data, node->data) < 0) // o meu primeiro numero e inferior
    {
        new->next = *begin_list;
        *begin_list =  new;
        return;   
    }
    while(node->next && cmp(data, node->next->data) >= 0)
    {
        node = node->next;
    }
    
    new->next = node->next;
    node->next = new;
}

int main(int ac, char **av)
{
    if(ac < 2)
        return 1;   
    
    int i = 1; 
    int *d = malloc(sizeof(int));

    *d = 10;
    
    t_list *list = NULL;
    while(i < ac)
    {
        if(!ft_isNum(av[i]))
        {
            printf("POE NUMEROS CRLHS!");
            return 1;
        }
        int val = ft_atoi(av[i]);
        ft_sorted_list_insert(&list, &val, cmp);
        i++;    
    }
    run_list(list);
    printf("\n");
    free_list(&list);
    return 0;
}

/*
Exercício Base: Ordenar usando duas pilhas

Objetivo:
Dada uma lista de números passados via argv, você deve organizar os números em ordem crescente usando apenas duas pilhas (stack_a e stack_b) e operações limitadas:

sa / sb – troca os dois primeiros elementos da pilha.

pa / pb – move o topo de uma pilha para a outra.

ra / rb – rotaciona a pilha (o topo vai para o final).

rra / rrb – rotaciona a pilha ao contrário (o final vai para o topo).

Estrutura sugerida:

typedef struct s_list
{
    int data;
    struct s_list *next;
} t_list;


stack_a inicia com todos os números da entrada (argv).

stack_b inicia vazia.

Passos do exercício:

Criar stack_a com os números passados.

Criar stack_b vazia.

Implementar funções básicas:

push(t_list **from, t_list **to) – equivalente a pa ou pb.

swap(t_list **stack) – equivalente a sa ou sb.

rotate(t_list **stack) – equivalente a ra ou rb.

reverse_rotate(t_list **stack) – equivalente a rra ou rrb.

Criar um algoritmo que mova elementos de stack_a para stack_b e depois volte para stack_a em ordem crescente, usando as funções acima.

Dicas:

Comece simples: só tente ordenar 3 números. Depois passe para 5, depois N.

Use ft_sorted_list_insert como referência para decidir onde colocar um número na outra pilha.

Tente escrever uma função is_sorted(stack) para testar se stack_a já está ordenada.

Se você quiser, eu posso te escrever um esqueleto em C com duas pilhas e funções de movimentação (push, swap, rotate) para você começar a implementar o algoritmo do Push Swap.*/
    

1️⃣ Operações de swap

sa → troca os dois primeiros de A 1

sb → troca os dois primeiros de B

ss → sa + sb ao mesmo tempo

2️⃣ Operações de push

pa → topo de B para A

pb → topo de A para B

3️⃣ Operações de rotate

ra → primeiro de A vai para o fim 1 

rb → primeiro de B vai para o fim

rr → ra + rb ao mesmo tempo

4️⃣ Operações de reverse rotate

rra → último de A vai para o topo

rrb → último de B vai para o topo

rrr → rra + rrb ao mesmo tempo

--------------------------------------

#SAGRADO#

a ft_shortbreak e a funcao sagrada para conseguir utilizar os meus sort de forma mais eficiente
    - a shortbreak procura a posicao do meu valor MIn que estou a procura
        - apos encontrar a posicao da mesma ou + proximo do meu inicio ou mais longe
                    - da uns dos comandos ou troca os primeiros 2 ! ou manda os ultimos 2 para o inicio
com isso a minhas sort3 ficou melhor !

#ANTES-
void ft_sort3(t_list **stacka) 
{
    if(!stacka || ft_list_size(*stacka) < 3) // condicao principal
        return;
    if(ft_is_sorted(*stacka) == 0)
        return;
    t_list *node;   
    int first;
    int second;
    int third;
     
    node = *stacka;
    first = *(int*)node->data;
    second = *(int*)node->next->data;
    third= *(int*)node->next->next->data;
    if(first > second && second < third && first > third) // 312
        ft_ra(stacka);
    else if(first < second && second > third && first > third) //231 x
        ft_rra(stacka);
    else if(first > second && second < third && third > first) //213
        ft_sa(stacka);
    else if(first > second && second > third) //321 x
        (ft_ra(stacka), ft_sa(stacka));
    else if(first < second && second > third && first < third) //132 x
        (ft_sa(stacka), ft_ra(stacka));
}

#DEPOIS
void ft_sort3(t_list **stacka, t_list **stackb)
{
    if(!stacka || ft_list_size(*stacka) < 2)
        return;
    if(ft_is_sorted(*stacka) == 0)
        return;
    t_list *node;
    t_list *max;

    max = *stacka;
    node = *stacka;
    while(node)
    {
        if(*(int*)max->data > *(int*)node->data)
            max = node;
        node = node->next;
    }
    ft_shortbreak(stacka, max, ft_list_size(*stacka));
    ft_pb(stacka, stackb);
    ft_sort2(stacka);
    ft_pa(stacka, stackb);
}

- IMPLEMENTACAO DO MEU SORT4
    porque?
        - pq a minha sort5 ja estava grande kkkk e fui na preguica , pq se n, era so fazer um sort2
            aos valores passados na stackb para depois sim mandar eles para a minha stacka
            - so que isso ia pedir mais condicoes entao modulei a sort4.
- criacao da sort4 (logica)

void ft_sort4(t_list **stacka, t_list **stackb)
{
    if(!stacka || ft_list_size(*stacka) < 4) // nul ou n tem o numero de elem.
        return;
    if(ft_is_sorted(*stacka) == 0) // ja esta sorted
        return;
    t_list *tmp = *stacka; // refernecia
    t_list *max = *stacka; // valores max
    
    while(tmp) // percorre a lista a procura do mair valor!
    {
        if(*(int*)max->data > *(int*)tmp->data)
            max = tmp; // meu novo valor maximo.
        tmp = tmp->next; // atualiza a lista.
    }
    ft_shortbreak(stacka, max, ft_list_size(*stacka));
    ft_pb(stacka, stackb);
    ft_sort3(stacka, stackb);
    ft_pa(stacka, stackb);
}

    -mesma logica utiliza!
        - verificao de NULL e de valores
        - verificao da is_sorted
        - apos isso a mesma logica:
        
        - dois valores tipo t_list! um max/min que vai ter o msm valor da minha tmp
            - pois serve somente para comparacao
        - um loop que percorre com uma condicao de comparacao de valores
            - caso houver um valor maior/inferior ao max/min -- atualiza o mesmo
        - apos encontrar - manda shortbreak ! -- diz me onde esta -- faz o calculo para ou usar RA ou RRA
        - mandar entao o valor prentendio para stackb
        - dar sort pretendido de acordo com o numero restante -- se sobrar 3 da sort3 etc...
        - mandar de volta o valor da stack para a stacka.
         

#CONDICOES DE SEGURANCA
    - primeiro verificar se o meu valor e NULL ! !stack 
        ou 
    - verificar se o tamanho esta de acordo com o sort ! 
        - ft_listsize!! < ao valor do sort(ex para sort3 o valor tem de ser == 3 se for < == return)
    - apos isso verificar se ja esta sorted!
        ft_isorted 
            - simplesmente faz um loop e ve se ha um valor *(int*)stacka->data > *(int)stacka->next->data
                se for verdade logo n esta sorted ... se ao chegar ao fim , n houve quebra de condicao 
                    - e true -- sorted.
--------------------------------------
novo bug: (08/01/26)
        - agora tenho de me preocupar com este caso:
            - ./pushswap "1 5 3 4"; ou ./pushswap 1 "3 2" 4
    SOLUCAO:
        - USO DA SPLIT === "1 5 3 4" .. 1534 - para depois a atoi pegar cada char.
        - USO DA STRJOIN === caso "1 9 2" "8  5"; -- e ficar somente com uma string - atoi no fim.


        ...tive de fazer 2 splits! pois a minha primeira tinha linhas a mais...


/*  #include "struct.h"



int ft_space(char c)
{
	return (c == 32 || c >= 9 && c <= 13);
}

int ft_cw(char *s)
{
	int i = 0;
	int c = 0;

	while(s[i])
	{
		while(s[i] && ft_space(s[i]))
			i++;
		if(s[i])
		{
			c++;
			while(s[i] && !ft_space(s[i]))
				i++;
		}
	}
	return c;
}

char *ft_getwords(char *s) // pego palavras.
{
	int i = 0;
	int len = 0;
	char *wd;
	
	while(s[len] && !ft_space(s[len]))
		len++;
	wd = malloc(len + 1);
	if(!wd)
		return NULL;
	while(i < len)
	{
		wd[i] = s[i];
		i++;
	}
	wd[i] = '\0';
	return wd;
}

int ft_fw(char **ar, char *s)
{
	int i = 0;
	int j = 0;
	while(s[i])
	{
		while(s[i] && ft_space(s[i])) // pula espacos
			i++;
		if(s[i]) // palavra!
		{
			ar[j] = ft_getwords(&s[i]); // pega a palvra associa ao array.
			if(!ar[j]) // condicao de seguranca.
			{
				while(j > 0) // LIMPA 
					free(ar[--j]);
				return 0;
			}
			while(s[i] && !ft_space(s[i]))
				i++;
			j++;
		}
	}
	return 1;
}
*/
/*
	- dar fill !
		- pegar a palvra.
		- caso for espaco -- pula
			- se ainda n for null
				- associa a palvra ao arr.
					- condicao de seguranca -- free ate chegar a 0 e return 0;
				- se nao , enquanto n chegar ao fim , pula os char.
*/

/*char	**ft_split(char *s)
{
	int len = ft_cw(s);
	char **ar = malloc(sizeof(char *) * (len + 1));
	if(!ar)
		return NULL;
	if(!s)
		return NULL;
	if(!ft_fw(ar, s))
	{
		free(ar);
		return NULL;
	}
	ar[len] = NULL;
	return ar;
}*/
/*
	- entender o len da palavra
		criar o arr --- que recebe o tamanho total das palavras pegas/
		 as condicoes de seguranca 
		 		
		se a ft_fw nao falhar.
			free(no array)
			return NULL;
			
		arr[len] = NULL (array valido)
		RETURN ARR'
*/

/*int main()
{
	char *s = " 1   5 6 7     4 ";
	char **ar = ft_split(s);
	int i = 0;
	while(ar[i])
		printf("%s", ar[i++]);
	return 0;
}*/

/*
int ft_space(char c)
{
	return (c == 32);
}

int ft_wlen(char *s)
{
	int i = 0;
	int c = 0;

	while(s[i])
	{
		while(s[i] && ft_space(s[i]))
			i++;
		if(s[i])
		{
			c++;
			while(s[i] && !ft_space(s[i]))
				i++;
		}
		i++;
	}
	return c;
}

char    **ft_split(char *str)
{
    char **ar;
    int i = 0;
    int j = 0;
	
    ar = malloc(sizeof(char*) * (ft_wlen(str) + 1)); // alocar espaco no arr
    if(!ar)
        return NULL;
    while(str[i]) // pegar cada palvra.
    {
        while(ft_space(str[i]))
            i++;
        if(str[i])
        {  
            int start = i;
            while(str[i] && !ft_space(str[i]))
                i++;
            int len = i - start;
            ar[j] = malloc(len + 1);
            if(!ar[j]) 
                return NULL;
            int k = 0;
            while(k < len)
            {
                ar[j][k] = str[start + k];
                k++;
            }
            ar[j][k] = '\0';
            j++;    
        }
    }
    ar[j] = NULL;
    return ar;
}

int main()
{
	char *s = "1 3 4     5";
	char **ar = ft_split(s);
	int i = 0;
	while(ar[i])	
		printf("%s", ar[i++]);
	return 0;
}*/

--------------------------------------

NOVO DESAFIO ANTES DE FINALIZAR O PROJETO:

    -fim do PROJETO
            - a questao que falta:
                    -modular o projeto + norminette == GG.

            - aprender como evitar o msm erro --- encher a main de funcoes e comemecar a pensar nela como ... um "orquestrador" - e nao um executor.
    A main só deve:
        Inicializar 
        Chamar módulos
        Verificar erros
        Finalizar   

boa visualizacao de uma main:
[ main ]
   |
   v
[ parser ] ---> [ validator ]
   |
   v
[ stack builder ]
   |
   v
[ algorithm ]

... 
tentar ver as coisas como caixas onde cada uma tera a sua funcao ... e nao ,chamar funcao , por uma condicao , caso errado == dar free etc...
    - ou seja so chama , se retornar (1 , NULL) faz x --- se n , poxima fase.
 ..
 ate agora a minha maior duvida esta aqui!!
    - como posso usar uma main modular que -- usa varios argumentos( av[i] -- ac)
    - como posso fazer isso sabendo que ainda tenho um arr - split + passar isso para a stack

[ parser ] ---> [ validator ]
   |
   v
[ stack builder ]??

...
    regras a serem seguidas:
        - nao  pode haver funcoes explicitas.
        -  gerir memoria etc.


logo eu so preciso de uma funcao que  
    - recebes os av[i]
    - passar para um arr
    

ou seja - arr -> recebe args - passados pela a plit.
    - save_atoi verifica se dentro do meu arry os args sao bons;
        
...

apos algum tempo ->passei isto:
    -> sem split e sem array:
    
/int main(int ac, char **av)
{
    int i = 1;
    t_list *stacka = NULL;
    t_list *stackb = NULL;
    int val;

    if(ac <= 2)
        return 0;
    while(i < ac)
    {
        if(!ft_save_atoi(av[i], &val)) // error aqui 
            return 1;
        if(ft_repeat_elem(stacka, val)) // error aqui
            return 1;
        ft_append(&stacka, &val, sizeof(int));
        i++; 
    }
    ft_picksort(&stacka, &stackb , ft_list_size(stacka));
    ft_freelist(&stacka);
    ft_freelist(&stackb);
}
para isto !
    -> ja com a split --- mass 0% modulada e bastante caotica.
            ->que :
    ->percorrer os args.
    -> coloca no  arr -> com a split (av[i])! associa
    -> percorre o array -> com a save_atoi -> entende se e legit(-, a etc sao removidos)
    -> e como cada argumento valido sera passado para a stack -> entede se ha elementos repetidos.

            caso n for legit -> frearr(ar)->error , return 1;
int main(int ac, char **av)
{
    int i = 1;
    int j = 0;
    t_list *stacka = NULL;
    t_list *stackb = NULL;
    int val;
    while(i < ac)
    {
        char **ar = ft_split(av[i]);
        if(!ar || !ar[0])
        {
            write(1, "error\n", 6);
            return 1;
        }
        j = 0; // reiniciar a contagem
        while(ar[j]) // modular isto !!!!
        {
            if(!ft_save_atoi(ar[j], &val) ||ft_repeat_elem(stacka, val))
            {
                ft_free(ar);
                write(1, "error\n", 6);
                return 1;
            }
            j++;
            ft_append(&stacka, &val, sizeof(int));
        }
        i++;
        ft_free(ar);
    }
    ft_picksort(&stacka, &stackb , ft_list_size(stacka));
    ft_freelist(&stacka);
    ft_freelist(&stackb);
    return 0;
}
para esta ideia:
 
n sei o nome mais ideal mas -> 
int ft_getarr(char *str, t_list *stacka) // tentar criar um arry que pega os digitos ? ->
{
    int j;
    int val;
    char **ar;
    
    ar = ft_split(str); // pega a minha string.
    j = 0;
    if(!ar || !ar[0]) // condicao de seguranca;
    {
        write(1, "error\n", 6);
        return 1;
    }
    while(ar[j])
    {
        if(!ft_save_atoi(ar[j], &val)|| ft_repeat_elem(*stacka, val)) // associar os meu valores 
        {
            ft_free_arr(ar);
            write(1, "arror\n", 6);
            return  1;
        }
        j++;
        ft_append(stacka, &val, sizeof(int));
    }
    free(ar);
    return 0;
}

aqui tiro a ideia da " na main iniciliado o arr para depois fazer o parse nele para"
-> cria uma funcao int ft_getarr(char *str, t_list *stacka) -> que pega os meus args[i] + stacka;

    -> na funcao:
        -> crio o arry = ft_split;
        -> faco o parsing nele (se e null , se so contem 1 elem etc);
        -> e percorre ele :
            -> save atoi + repeat elem --- msm conceito so que caso der erro :
                -> free no array, escreve erro , return 1;

FINAL MAIN ->:
    
int main(int ac, char **av)
{
    int i = 1;
    t_list *stacka = NULL;
    t_list *stackb = NULL;
    while(i < ac) // parsing de argumentos
    {
        if(!ft_getarr(av[i], &stacka))
            return 1;
        i++;
    }
    ft_picksort(&stacka, &stackb , ft_list_size(stacka));
    ft_freelist(&stacka);
    ft_freelist(&stackb);
    return 0;
}
-> falta so acabar a save_atoi;

/*
    #include "struct.h"

static int ft_strlen(char *s)
{
	int i = 0;
	while(s[i])
		i++;
	return i;
}

char *ft_strjoin(char *s1, char *s2)
{
	int i = 0;
	int j = 0;
	int l1 = ft_strlen(s1);
	int l2 = ft_strlen(s2);
	if(!s1 || !s2)
		return NULL;
	char *s = malloc((l1 + l2) + 1);
	if(!s)
		return NULL;
	while(i < l1)
	{
		s[i] = s1[i];
		i++;
	}
	while(j < l2)
		s[i++] = s2[j++];
	s[i] = '\0';
	return s;
}
int main()
{
	char a[] = "ola ";
	char b[] = "mundo";
	char *result = ft_strjoin(a, b);
	printf("%s", result);
	return 0;
}
*/